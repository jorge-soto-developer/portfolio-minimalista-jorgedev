import {
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __publicField
} from "./chunk-MZQ22LAU.js";

// node_modules/hotkeypad/dist/utils.js
function createElement(tag, props) {
  const element = document.createElement(tag);
  if (props && typeof props === "string" && props !== "")
    element.textContent = props;
  if (props && typeof props === "object")
    Object.keys(props).forEach((key) => {
      element.setAttribute(key, props[key]);
    });
  return element;
}
function createListener(element, event, callback) {
  element.addEventListener(event, callback);
}
function extractHotkeyLetter(hotkey) {
  var _a;
  const key = ((_a = hotkey.match(/\w+$/)) == null ? void 0 : _a[0]) ?? "";
  return key === "" || key.length > 1 ? "" : key.toUpperCase();
}
var VALID_META_KEYS = ["Control", "Shift", "Alt", "Meta"];
var NOT_ALLOWED_HOTKEYS = [
  "Control+T",
  "Control+Shift+T",
  "Control+W",
  "Control+Shift+W",
  "Control+N",
  "Control+Shift+N",
  "Control+Tab",
  "Control+Shift+Tab",
  "Meta+T",
  "Meta+Shift+T",
  "Meta+W",
  "Meta+Shift+W",
  "Meta+N",
  "Meta+Shift+N",
  "Meta+Tab",
  "Meta+Shift+Tab"
];
function isValidHotkey(hotkey) {
  const keys = hotkey.match(/\w+/g) ?? [];
  if (keys.length === 0)
    return false;
  const hotkeyString = keys.map((key) => {
    if (key.toUpperCase() === "CTRL")
      return "Control";
    if (key.toUpperCase() === "CMD")
      return "Meta";
    return key[0].toUpperCase() + key.slice(1).toLowerCase();
  }).join("+");
  return !NOT_ALLOWED_HOTKEYS.includes(hotkeyString) && hotkeyString.split("+").slice(0, -1).every((key) => VALID_META_KEYS.includes(key));
}

// node_modules/hotkeypad/dist/index.js
var _backdrop, _container, _commands, _closeKey, _activationKey, _activationLetter, _placeholder, _emptyMessage, _svgIconColor, _observer, _HotKeyPad_instances, init_fn, checkTagOptions_fn, observeClassChanges_fn, setListeners_fn, activateItem_fn, verifyCommands_fn, hasCustomFooter_fn, isOpen_get, sections_get, items_get, iconURL_fn, isCustomIcon_fn, createBackdrop_fn, createContainer_fn, createHeader_fn, createFooter_fn, createSections_fn, renderCommands_fn;
var HotKeyPad = class {
  constructor({ closeKey, placeholder, emptyMessage, activationLetter } = {}) {
    __privateAdd(this, _HotKeyPad_instances);
    __publicField(this, "instance");
    __privateAdd(this, _backdrop, null);
    __privateAdd(this, _container, null);
    __privateAdd(this, _commands, []);
    __publicField(this, "currentIndex", 0);
    __privateAdd(this, _closeKey, "Escape");
    __privateAdd(this, _activationKey);
    __privateAdd(this, _activationLetter, "K");
    __privateAdd(this, _placeholder, "Search command");
    __privateAdd(this, _emptyMessage, "No commands found");
    __privateAdd(this, _svgIconColor, "black");
    __privateAdd(this, _observer, new MutationObserver(__privateMethod(this, _HotKeyPad_instances, observeClassChanges_fn).bind(this)));
    if (document.getElementById("hotkeypad") == null) {
      throw new Error("HotKeyPad instance not found in the DOM");
    }
    this.instance = document.getElementById("hotkeypad");
    __privateSet(this, _activationKey, navigator.userAgent.includes("Macintosh") ? "Cmd" : "Ctrl");
    if (closeKey && closeKey !== "")
      __privateSet(this, _closeKey, closeKey);
    if (placeholder && placeholder !== "")
      __privateSet(this, _placeholder, placeholder);
    if (emptyMessage && emptyMessage !== "")
      __privateSet(this, _emptyMessage, emptyMessage);
    if (activationLetter && activationLetter !== "")
      __privateSet(this, _activationLetter, activationLetter);
    __privateMethod(this, _HotKeyPad_instances, checkTagOptions_fn).call(this);
    __privateMethod(this, _HotKeyPad_instances, init_fn).call(this);
    return this;
  }
  /* PUBLIC METHODS */
  open() {
    window.dispatchEvent(new CustomEvent("hotkeypad:open"));
    this.instance.style.opacity = "1";
    this.instance.style.visibility = "visible";
    this.instance.style.pointerEvents = "auto";
    setTimeout(() => __privateGet(this, _container).querySelector("input").focus(), 200);
  }
  close() {
    window.dispatchEvent(new CustomEvent("hotkeypad:close"));
    this.instance.style.opacity = "0";
    this.instance.style.visibility = "hidden";
    this.instance.style.pointerEvents = "none";
    __privateGet(this, _container).querySelector("input").value = "";
    __privateGet(this, _container).removeEventListener("keydown", () => {
    });
    __privateGet(this, _container).removeEventListener("mouseover", () => {
    });
    __privateGet(this, _container).removeEventListener("input", () => {
    });
  }
  setCommands(commands) {
    __privateSet(this, _commands, __privateMethod(this, _HotKeyPad_instances, verifyCommands_fn).call(this, commands));
    __privateMethod(this, _HotKeyPad_instances, renderCommands_fn).call(this);
    __privateMethod(this, _HotKeyPad_instances, setListeners_fn).call(this);
  }
  get activationKey() {
    return __privateGet(this, _activationKey);
  }
  get emptyMessage() {
    const message = createElement("div", __privateGet(this, _emptyMessage));
    message.setAttribute("data-empty", "");
    return message;
  }
};
_backdrop = new WeakMap();
_container = new WeakMap();
_commands = new WeakMap();
_closeKey = new WeakMap();
_activationKey = new WeakMap();
_activationLetter = new WeakMap();
_placeholder = new WeakMap();
_emptyMessage = new WeakMap();
_svgIconColor = new WeakMap();
_observer = new WeakMap();
_HotKeyPad_instances = new WeakSet();
/* CONFIGURATION METHODS */
init_fn = function() {
  createListener(document, "keydown", (event) => {
    const keyCode = `Key${__privateGet(this, _activationLetter).toUpperCase()}`;
    if (event.code === keyCode && (event.metaKey || event.ctrlKey)) {
      event.preventDefault();
      __privateGet(this, _HotKeyPad_instances, isOpen_get) ? this.close() : this.open();
    }
    if (event.key.toLowerCase() === __privateGet(this, _closeKey).toLowerCase())
      this.close();
  });
  __privateGet(this, _observer).observe(this.instance, {
    attributes: true,
    attributeFilter: ["class"],
    childList: false,
    characterData: false
  });
  __privateMethod(this, _HotKeyPad_instances, createBackdrop_fn).call(this);
  __privateMethod(this, _HotKeyPad_instances, createContainer_fn).call(this);
  __privateMethod(this, _HotKeyPad_instances, createHeader_fn).call(this);
  __privateMethod(this, _HotKeyPad_instances, createFooter_fn).call(this);
};
checkTagOptions_fn = function() {
  if (this.instance.hasAttribute("data-placeholder") && this.instance.getAttribute("data-placeholder") !== "") {
    __privateSet(this, _placeholder, this.instance.getAttribute("data-placeholder"));
  }
  if (this.instance.hasAttribute("data-activation-letter") && this.instance.getAttribute("data-activation-letter") !== "") {
    __privateSet(this, _activationLetter, this.instance.getAttribute("data-activation-letter").toUpperCase());
  }
  if (this.instance.hasAttribute("data-close-key") && this.instance.getAttribute("data-close-key") !== "") {
    __privateSet(this, _closeKey, this.instance.getAttribute("data-close-key").toUpperCase());
  }
};
observeClassChanges_fn = function(event) {
  const { attributeName, target } = event[0];
  if (attributeName === "class") {
    if (target.classList.contains("dark"))
      __privateSet(this, _svgIconColor, "white");
    else
      __privateSet(this, _svgIconColor, "black");
    __privateMethod(this, _HotKeyPad_instances, renderCommands_fn).call(this);
  }
};
setListeners_fn = function() {
  createListener(this.instance, "keydown", (event) => {
    if (event.metaKey || event.ctrlKey) {
      __privateGet(this, _commands).find(({ hotkey, handler }) => {
        const keyLetter = extractHotkeyLetter(hotkey);
        const keyCode = `Key${keyLetter}`;
        if (event.code === keyCode) {
          event.preventDefault();
          if (handler != null)
            setTimeout(() => handler(this.instance), 200);
          this.close();
        }
        return false;
      });
    }
  });
  createListener(__privateGet(this, _container), "click", (event) => {
    var _a;
    const item = event.target;
    if (item.tagName === "LI")
      __privateMethod(this, _HotKeyPad_instances, activateItem_fn).call(this, item);
    if (((_a = item.parentElement) == null ? void 0 : _a.tagName) === "LI")
      __privateMethod(this, _HotKeyPad_instances, activateItem_fn).call(this, item.parentElement);
  });
  createListener(__privateGet(this, _container), "mouseover", (event) => {
    const item = event.target;
    if (item.tagName === "LI") {
      __privateGet(this, _HotKeyPad_instances, items_get).forEach((item2) => item2.removeAttribute("data-active"));
      item.setAttribute("data-active", "");
    }
  });
  createListener(__privateGet(this, _container), "keydown", (event) => {
    const items = __privateGet(this, _HotKeyPad_instances, items_get);
    this.currentIndex = Array.from(items).findIndex((item) => item.hasAttribute("data-active"));
    this.currentIndex = this.currentIndex === -1 ? 0 : this.currentIndex;
    let nextIndex = 0;
    if (event.key === "Enter") {
      event.preventDefault();
      __privateMethod(this, _HotKeyPad_instances, activateItem_fn).call(this, items[this.currentIndex]);
      items[this.currentIndex].removeAttribute("data-active");
      this.currentIndex = 0;
    }
    if (event.key === "ArrowUp") {
      event.preventDefault();
      nextIndex = this.currentIndex - 1 < 0 ? items.length - 1 : this.currentIndex - 1;
    }
    if (event.key === "ArrowDown") {
      event.preventDefault();
      nextIndex = this.currentIndex + 1 > items.length - 1 ? 0 : this.currentIndex + 1;
    }
    if (event.key === "Tab") {
      event.preventDefault();
      nextIndex = this.currentIndex + 1 > items.length - 1 ? 0 : this.currentIndex + 1;
    }
    items[this.currentIndex].removeAttribute("data-active");
    items[nextIndex].setAttribute("data-active", "");
  });
  createListener(__privateGet(this, _container), "input", (event) => {
    const input = event.target;
    const value = input.value.toLowerCase();
    const sections = __privateGet(this, _container).querySelectorAll("[data-section]");
    const emptySection = __privateGet(this, _container).querySelector("[data-empty]");
    sections.forEach((section) => {
      const list = section.querySelector("ul");
      const items = list.querySelectorAll("li");
      items.forEach((item) => {
        const title = item.querySelector("p").innerText.toLowerCase();
        if (title.includes(value))
          item.style.display = "flex";
        else
          item.style.display = "none";
      });
      const visibleItems = list.querySelectorAll("li[style='display: flex;']");
      if (visibleItems.length === 0)
        section.style.display = "none";
      else
        section.style.display = "block";
    });
    const visibleSections = __privateGet(this, _container).querySelectorAll("[data-section][style='display: block;']");
    if (visibleSections.length === 0)
      emptySection.style.display = "flex";
    else
      emptySection.style.display = "none";
  });
};
/* HELPER METHODS */
/**
 * Activate the item with the corresponding hotkey
 * @param item The item to activate
 * @executes The handler of the item
 */
activateItem_fn = function(item) {
  __privateGet(this, _commands).find(({ hotkey, handler }) => {
    if (item.getAttribute("data-hotkey") === hotkey) {
      if (handler != null)
        setTimeout(() => handler(this.instance), 200);
      this.close();
    }
    return false;
  });
};
/**
 * Verify the commands array
 * @param commands The commands array to verify
 * @returns The verified commands array
 * @throws An error if the commands array is not valid
 */
verifyCommands_fn = function(commands) {
  if (commands.length === 0)
    throw new Error("The commands array cannot be empty");
  commands.forEach((command) => {
    if (command.id === "" || command.title === "" || command.hotkey === "" || command.handler == null)
      throw new Error("The command object is not valid. It should contain an id, title, hotkey and handler");
    if (!isValidHotkey(command.hotkey))
      throw new Error("The hotkey is not valid. It should only contain CTRL, CMD, ALT, SHIFT and a letter. Also it cannot contain browser or system reserved hotkeys such as CTRL+T, CTRL+N, CTRL+W, etc.");
    if (command.icon != null && typeof command.icon !== "string")
      throw new Error("The icon should be a string");
    const keys = command.hotkey.match(/\w+/g) ?? [];
    if (keys.length > 2)
      throw new Error("The hotkey only supports 2 keys maximum");
  });
  return commands;
};
hasCustomFooter_fn = function(footerEl) {
  const template = document.querySelector("#hotkeypad-footer");
  if (template == null)
    return false;
  const clone = template.content.cloneNode(true);
  const children = Array.from(clone.children);
  children.forEach((child) => footerEl.appendChild(child));
  return true;
};
isOpen_get = function() {
  return this.instance.style.visibility === "visible";
};
sections_get = function() {
  const map = /* @__PURE__ */ new Map();
  __privateGet(this, _commands).forEach((item) => {
    const key = typeof item.section !== "string" || item.section === "" ? "Unlisted" : item.section;
    const { section, ...content } = item;
    const collection = map.get(key);
    if (!collection)
      map.set(key, [content]);
    else
      collection.push(content);
  });
  return Array.from(map);
};
items_get = function() {
  return __privateGet(this, _container).querySelectorAll("li");
};
/* ICON METHODS */
iconURL_fn = function(icon) {
  return `https://cdn.simpleicons.org/${icon}/${__privateGet(this, _svgIconColor)}`;
};
isCustomIcon_fn = function(icon) {
  return /<svg/.test(icon) || /<img/.test(icon) || /<i/.test(icon) || icon === "";
};
/* RENDERING METHODS */
createBackdrop_fn = function() {
  __privateSet(this, _backdrop, createElement("div", {
    "data-backdrop": "",
    "aria-hidden": "true"
  }));
  createListener(__privateGet(this, _backdrop), "click", () => this.close());
  this.instance.appendChild(__privateGet(this, _backdrop));
};
createContainer_fn = function() {
  __privateSet(this, _container, createElement("div", { "data-container": "" }));
  this.instance.appendChild(__privateGet(this, _container));
};
createHeader_fn = function() {
  const headerEl = createElement("header");
  const inputEl = createElement("input", {
    type: "text",
    name: __privateGet(this, _placeholder).toLocaleLowerCase(),
    placeholder: __privateGet(this, _placeholder),
    "aria-label": __privateGet(this, _placeholder),
    autocomplete: "off",
    spellcheck: "false"
  });
  headerEl.appendChild(inputEl);
  __privateGet(this, _container).appendChild(headerEl);
};
createFooter_fn = function() {
  const footerEl = createElement("footer");
  if (!__privateMethod(this, _HotKeyPad_instances, hasCustomFooter_fn).call(this, footerEl)) {
    const keyEnter = createElement("kbd", "↩");
    const keyUp = createElement("kbd", "↑");
    const keyDown = createElement("kbd", "↓");
    const keyEsc = createElement("kbd", __privateGet(this, _closeKey));
    const keyCmdK = createElement("kbd", `${__privateGet(this, _activationKey)} + ${__privateGet(this, _activationLetter)}`);
    const pEnter = createElement("p", " to select");
    const pUpDown = createElement("p", " to navigate");
    const pCmdK = createElement("p", " to close");
    pEnter.prepend(keyEnter);
    pUpDown.prepend(keyUp, keyDown);
    pCmdK.prepend(keyCmdK, keyEsc);
    footerEl.append(pEnter, pUpDown, pCmdK);
  }
  __privateGet(this, _container).appendChild(footerEl);
};
createSections_fn = function() {
  const sectionsEl = createElement("div");
  sectionsEl.setAttribute("data-sections", "");
  __privateGet(this, _HotKeyPad_instances, sections_get).forEach(([section, commands]) => {
    const sectionEl = createElement("div");
    sectionEl.setAttribute("data-section", section.toLowerCase());
    if (section !== "Unlisted") {
      const titleEl = createElement("h4", section);
      titleEl.setAttribute("id", `section-${section.toLowerCase()}`);
      sectionEl.setAttribute("aria-labelledby", `section-${section.toLowerCase()}`);
      sectionEl.appendChild(titleEl);
    }
    const listEl = createElement("ul");
    commands.forEach(({ title, icon, hotkey }) => {
      const keys = hotkey.split("+").map((key) => key.trim());
      if (icon == null)
        icon = "";
      const stringIcon = __privateMethod(this, _HotKeyPad_instances, isCustomIcon_fn).call(this, icon) ? icon : `<img src="${__privateMethod(this, _HotKeyPad_instances, iconURL_fn).call(this, icon)}" alt="${title}" />`;
      const itemEl = createElement("li");
      itemEl.setAttribute("data-hotkey", hotkey);
      if (stringIcon !== "") {
        const itemIcon = createElement("span");
        itemIcon.innerHTML = stringIcon;
        itemEl.appendChild(itemIcon);
      }
      const itemTitle = createElement("p");
      itemTitle.append(title);
      const itemKeys = createElement("div");
      keys.forEach((key) => {
        const keyEl = createElement("span", key);
        itemKeys.appendChild(keyEl);
      });
      itemEl.appendChild(itemTitle);
      itemEl.appendChild(itemKeys);
      listEl.appendChild(itemEl);
    });
    sectionEl.appendChild(listEl);
    sectionsEl.appendChild(sectionEl);
  });
  sectionsEl.appendChild(this.emptyMessage);
  __privateGet(this, _container).insertBefore(sectionsEl, __privateGet(this, _container).lastChild);
};
renderCommands_fn = function() {
  const sectionsEl = __privateGet(this, _container).querySelector("[data-sections]");
  if (sectionsEl)
    sectionsEl.remove();
  __privateMethod(this, _HotKeyPad_instances, createSections_fn).call(this);
  __privateGet(this, _HotKeyPad_instances, items_get)[0].setAttribute("data-active", "");
};
export {
  HotKeyPad as default
};
//# sourceMappingURL=hotkeypad.js.map
